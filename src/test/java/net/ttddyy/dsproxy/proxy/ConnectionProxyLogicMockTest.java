package net.ttddyy.dsproxy.proxy;

import net.ttddyy.dsproxy.ConnectionInfo;
import net.ttddyy.dsproxy.listener.CallCheckMethodExecutionListener;
import net.ttddyy.dsproxy.listener.MethodExecutionContext;
import net.ttddyy.dsproxy.listener.QueryExecutionListener;
import net.ttddyy.dsproxy.proxy.jdk.PreparedStatementInvocationHandler;
import net.ttddyy.dsproxy.proxy.jdk.StatementInvocationHandler;
import org.junit.Test;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.instanceOf;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.notNullValue;
import static org.hamcrest.Matchers.sameInstance;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @author Tadaya Tsuyukubo
 */
public class ConnectionProxyLogicMockTest {

    @Test
    public void testCreateStatementWithNoParam() throws Throwable {
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        Method method = Connection.class.getMethod("createStatement");
        Object result = logic.invoke(conn, method, new Object[]{});

        assertThat(result, is(instanceOf(Statement.class)));
        verifyStatement((Statement) result);
        verify(conn).createStatement();
    }

    @Test
    public void testCreateStatementWithTwoParam() throws Throwable {
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);


        Method method = Connection.class.getMethod("createStatement", int.class, int.class);
        Object result = logic.invoke(conn, method, new Object[]{ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY});

        assertThat(result, is(instanceOf(Statement.class)));
        verifyStatement((Statement) result);
        verify(conn).createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
    }

    @Test
    public void testCreateStatementWithThreeParam() throws Throwable {
        // expect
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        // run
        Method method = Connection.class.getMethod("createStatement", int.class, int.class, int.class);
        Object result = logic.invoke(conn, method, new Object[]{ResultSet.TYPE_FORWARD_ONLY,
                ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT});

        // verify
        assertThat(result, is(instanceOf(Statement.class)));
        verifyStatement((Statement) result);

        verify(conn).createStatement(ResultSet.TYPE_FORWARD_ONLY,
                ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    private ConnectionProxyLogic getProxyLogic(Connection mockConnection) {
        QueryExecutionListener listener = mock(QueryExecutionListener.class);

        ConnectionInfo connectionInfo = new ConnectionInfo();
        connectionInfo.setDataSourceName("myDS");

        ProxyConfig proxyConfig = ProxyConfig.Builder.create().queryListener(listener).build();
        return new ConnectionProxyLogic(mockConnection, connectionInfo, proxyConfig);
    }

    private void verifyStatement(Statement statement) {
        assertThat(statement, notNullValue());

        assertThat(Proxy.isProxyClass(statement.getClass()), is(true));
        InvocationHandler handler = Proxy.getInvocationHandler(statement);
        assertThat(handler, is(instanceOf(StatementInvocationHandler.class)));
    }


    @Test
    public void testPrepareStatement() throws Throwable {
        // expect
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        String query = "select * from emp";

        // run
        Method method = Connection.class.getMethod("prepareStatement", String.class);
        Object result = logic.invoke(conn, method, new Object[]{query});

        // verify
        assertThat(result, is(instanceOf(PreparedStatement.class)));
        verifyPreparedStatement((PreparedStatement) result);
    }

    @Test
    public void testPrepareStatementWithAutoGeneratedKeys() throws Throwable {
        // expect
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        String query = "select * from emp";

        // run
        Method method = Connection.class.getMethod("prepareStatement", String.class, int.class);
        Object result = logic.invoke(conn, method, new Object[]{query, Statement.RETURN_GENERATED_KEYS});

        // verify
        assertThat(result, is(instanceOf(PreparedStatement.class)));
        verifyPreparedStatement((PreparedStatement) result);
        verify(conn).prepareStatement(query, Statement.RETURN_GENERATED_KEYS);
    }

    @Test
    public void testPrepareStatementWithColumnIndexes() throws Throwable {
        // expect
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        String query = "select * from emp";
        int[] columnIndexes = new int[]{1, 2, 3};

        // run
        Method method = Connection.class.getMethod("prepareStatement", String.class, int[].class);
        Object result = logic.invoke(conn, method, new Object[]{query, columnIndexes});

        // verify
        assertThat(result, is(instanceOf(PreparedStatement.class)));
        verifyPreparedStatement((PreparedStatement) result);
        verify(conn).prepareStatement(query, columnIndexes);
    }

    @Test
    public void testPrepareStatementWithColumnNames() throws Throwable {
        // expect
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        String query = "select * from emp";
        String[] columnNames = new String[]{"id", "name"};

        // run
        Method method = Connection.class.getMethod("prepareStatement", String.class, String[].class);
        Object result = logic.invoke(conn, method, new Object[]{query, columnNames});

        // verify
        assertThat(result, is(instanceOf(PreparedStatement.class)));
        verifyPreparedStatement((PreparedStatement) result);
        verify(conn).prepareStatement(query, columnNames);
    }

    @Test
    public void testPrepareStatementWithTwoResultSetParams() throws Throwable {
        // expect
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        String query = "select * from emp";

        // run
        Method method = Connection.class.getMethod("prepareStatement", String.class, int.class, int.class);
        Object result = logic.invoke(conn, method, new Object[]{query,
                ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY});


        // verify
        assertThat(result, is(instanceOf(PreparedStatement.class)));
        verifyPreparedStatement((PreparedStatement) result);
        verify(conn).prepareStatement(query,
                ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
    }

    @Test
    public void testPrepareStatementWithThreeResultSetParams() throws Throwable {
        // expect
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        String query = "select * from emp";

        // run
        Method method = Connection.class.getMethod("prepareStatement", String.class, int.class, int.class, int.class);
        Object result = logic.invoke(conn, method, new Object[]{query,
                ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT});

        // verify
        assertThat(result, is(instanceOf(PreparedStatement.class)));
        verifyPreparedStatement((PreparedStatement) result);
        verify(conn).prepareStatement(query,
                ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    private void verifyPreparedStatement(PreparedStatement statement) {
        assertThat(statement, notNullValue());

        assertThat(Proxy.isProxyClass(statement.getClass()), is(true));
        InvocationHandler handler = Proxy.getInvocationHandler(statement);
        assertThat(handler, is(instanceOf(PreparedStatementInvocationHandler.class)));
    }


    @Test
    public void testGetTarget() throws Throwable {
        Connection orig = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(orig);

        // run
        Method method = ProxyJdbcObject.class.getMethod("getTarget");
        Object result = logic.invoke(orig, method, null);

        assertThat(result, is(instanceOf(Connection.class)));
        Connection resultConn = (Connection) result;
        assertThat(resultConn, is(sameInstance(orig)));
    }

    @Test
    public void testUnwrap() throws Throwable {
        Connection mock = mock(Connection.class);
        when(mock.unwrap(String.class)).thenReturn("called");

        ConnectionProxyLogic logic = getProxyLogic(mock);

        // run
        Method method = Connection.class.getMethod("unwrap", Class.class);
        Object result = logic.invoke(mock, method, new Object[]{String.class});

        verify(mock).unwrap(String.class);
        assertThat(result, is(instanceOf(String.class)));
        assertThat((String) result, is("called"));
    }

    @Test
    public void testIsWrapperFor() throws Throwable {
        Connection mock = mock(Connection.class);
        when(mock.isWrapperFor(String.class)).thenReturn(true);

        ConnectionProxyLogic logic = getProxyLogic(mock);

        // run
        Method method = Connection.class.getMethod("isWrapperFor", Class.class);
        Object result = logic.invoke(mock, method, new Object[]{String.class});

        verify(mock).isWrapperFor(String.class);
        assertThat(result, is(instanceOf(boolean.class)));
        assertThat((Boolean) result, is(true));
    }

    @Test
    public void testToString() throws Throwable {
        Connection conn = mock(Connection.class);

        when(conn.toString()).thenReturn("my conn");
        ConnectionProxyLogic logic = getProxyLogic(conn);

        Method method = Object.class.getMethod("toString");
        Object result = logic.invoke(conn, method, null);

        assertThat(result, is(instanceOf(String.class)));
        assertThat((String) result, is(conn.getClass().getSimpleName() + " [my conn]"));
    }

    @Test
    public void testHashCode() throws Throwable {
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        Method method = Object.class.getMethod("hashCode");
        Object result = logic.invoke(conn, method, null);

        assertThat(result, is(instanceOf(Integer.class)));
        assertThat((Integer) result, is(conn.hashCode()));
    }

    @Test
    public void testEquals() throws Throwable {
        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = getProxyLogic(conn);

        Method method = Object.class.getMethod("equals", Object.class);

        // equals(null)
        Object result = logic.invoke(conn, method, new Object[]{null});
        assertThat(result, is(instanceOf(Boolean.class)));
        assertThat((Boolean) result, is(false));

        // equals(true)
        result = logic.invoke(conn, method, new Object[]{conn});
        assertThat(result, is(instanceOf(Boolean.class)));
        assertThat((Boolean) result, is(true));
    }

    @Test
    public void methodExecutionListener() throws Throwable {
        CallCheckMethodExecutionListener listener = new CallCheckMethodExecutionListener();
        ProxyConfig proxyConfig = ProxyConfig.Builder.create().methodListener(listener).build();
        ConnectionInfo connectionInfo = new ConnectionInfo();

        Connection conn = mock(Connection.class);
        ConnectionProxyLogic logic = new ConnectionProxyLogic(conn, connectionInfo, proxyConfig);

        Method method = Connection.class.getMethod("createStatement");
        logic.invoke(conn, method, new Object[]{});

        assertTrue(listener.isBeforeMethodCalled());
        assertTrue(listener.isAfterMethodCalled());

        MethodExecutionContext executionContext = listener.getAfterMethodContext();
        assertSame("method should come from interface",
                Connection.class, executionContext.getMethod().getDeclaringClass());
        assertSame("createStatement", executionContext.getMethod().getName());
        assertSame(conn, executionContext.getTarget());
        assertSame(connectionInfo, executionContext.getConnectionInfo());
    }

}
