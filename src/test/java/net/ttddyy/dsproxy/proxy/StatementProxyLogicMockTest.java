package net.ttddyy.dsproxy.proxy;

import net.ttddyy.dsproxy.ConnectionInfo;
import net.ttddyy.dsproxy.ExecutionInfo;
import net.ttddyy.dsproxy.QueryInfo;
import net.ttddyy.dsproxy.StatementType;
import net.ttddyy.dsproxy.listener.CallCheckMethodExecutionListener;
import net.ttddyy.dsproxy.listener.MethodExecutionContext;
import net.ttddyy.dsproxy.listener.NoOpQueryExecutionListener;
import net.ttddyy.dsproxy.listener.QueryExecutionListener;
import net.ttddyy.dsproxy.proxy.jdk.ResultSetInvocationHandler;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.ArgumentMatchers;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;

import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.reset;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;


/**
 * @author Tadaya Tsuyukubo
 */
public class StatementProxyLogicMockTest {

    private static final String DS_NAME = "myDS";

    @Test
    public void testExecuteUpdate() throws Throwable {
        final String query = "insert into emp (id, name) values (1, 'foo')";

        Statement stat = mock(Statement.class);
        when(stat.executeUpdate(query)).thenReturn(100);

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        Method method = Statement.class.getMethod("executeUpdate", String.class);
        Object result = logic.invoke(method, new Object[]{query});

        assertThat(result).isEqualTo(100);
        verify(stat).executeUpdate(query);
        verifyListener(listener, "executeUpdate", query, query);
    }

    @Test
    public void testExecuteUpdateForException() throws Throwable {
        final String query = "insert into emp (id, name) values (1, 'foo')";

        Statement stat = mock(Statement.class);
        when(stat.executeUpdate(query)).thenThrow(new SQLException());

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        try {
            Method method = Statement.class.getMethod("executeUpdate", String.class);
            logic.invoke(method, new Object[]{query});
            fail();
        } catch (SQLException e) {
        }

        verify(stat).executeUpdate(query);
        verifyListenerForException(listener, "executeUpdate", query, query);
    }

    @Test
    public void testExecuteUpdateWithAutoGeneratedKeys() throws Throwable {
        final String query = "insert into emp (id, name) values (1, 'foo')";

        Statement stat = mock(Statement.class);
        when(stat.executeUpdate(query, Statement.RETURN_GENERATED_KEYS)).thenReturn(100);

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        Method method = Statement.class.getMethod("executeUpdate", String.class, int.class);
        Object result = logic.invoke(method, new Object[]{query, Statement.RETURN_GENERATED_KEYS});

        assertThat(result).isEqualTo(100);
        verify(stat).executeUpdate(query, Statement.RETURN_GENERATED_KEYS);
        verifyListener(listener, "executeUpdate", query, query, Statement.RETURN_GENERATED_KEYS);
    }

    @Test
    public void testExecuteUpdateWithAutoGeneratedKeysForException() throws Throwable {
        final String query = "insert into emp (id, name) values (1, 'foo')";

        Statement stat = mock(Statement.class);
        when(stat.executeUpdate(query, Statement.RETURN_GENERATED_KEYS)).thenThrow(new SQLException());

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        try {
            Method method = Statement.class.getMethod("executeUpdate", String.class, int.class);
            logic.invoke(method, new Object[]{query, Statement.RETURN_GENERATED_KEYS});
            fail();
        } catch (SQLException e) {
        }

        verify(stat).executeUpdate(query, Statement.RETURN_GENERATED_KEYS);
        verifyListenerForException(listener, "executeUpdate", query, query, Statement.RETURN_GENERATED_KEYS);
    }

    @Test
    public void testExecuteUpdateWithColumnIndexes() throws Throwable {
        final String query = "insert into emp (id, name) values (1, 'foo')";
        final int[] columnIndexes = {1, 2, 3};

        Statement stat = mock(Statement.class);
        when(stat.executeUpdate(query, columnIndexes)).thenReturn(100);

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        Method method = Statement.class.getMethod("executeUpdate", String.class, int[].class);
        Object result = logic.invoke(method, new Object[]{query, columnIndexes});

        assertThat(result).isEqualTo(100);
        verify(stat).executeUpdate(query, columnIndexes);
        verifyListener(listener, "executeUpdate", query, query, columnIndexes);
    }

    @Test
    public void testExecuteUpdateWithColumnIndexesForException() throws Throwable {
        final String query = "insert into emp (id, name) values (1, 'foo')";
        final int[] columnIndexes = {1, 2, 3};

        Statement stat = mock(Statement.class);
        when(stat.executeUpdate(query, columnIndexes)).thenThrow(new SQLException());

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        try {
            Method method = Statement.class.getMethod("executeUpdate", String.class, int[].class);
            logic.invoke(method, new Object[]{query, columnIndexes});
            fail();
        } catch (SQLException e) {

        }

        verify(stat).executeUpdate(query, columnIndexes);
        verifyListenerForException(listener, "executeUpdate", query, query, columnIndexes);
    }

    @Test
    public void testExecuteUpdateWithColumnNames() throws Throwable {
        final String query = "insert into emp (id, name) values (1, 'foo')";
        final String[] columnNames = {"foo", "bar", "baz"};

        Statement stat = mock(Statement.class);
        when(stat.executeUpdate(query, columnNames)).thenReturn(100);

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        Method method = Statement.class.getMethod("executeUpdate", String.class, String[].class);
        Object result = logic.invoke(method, new Object[]{query, columnNames});

        assertThat(result).isEqualTo(100);
        verify(stat).executeUpdate(query, columnNames);
        verifyListener(listener, "executeUpdate", query, query, columnNames);
    }

    @Test
    public void testExecuteUpdateWithColumnNamesForException() throws Throwable {
        final String query = "insert into emp (id, name) values (1, 'foo')";
        final String[] columnNames = {"foo", "bar", "baz"};

        Statement stat = mock(Statement.class);
        when(stat.executeUpdate(query, columnNames)).thenThrow(new SQLException());

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        try {
            Method method = Statement.class.getMethod("executeUpdate", String.class, String[].class);
            logic.invoke(method, new Object[]{query, columnNames});
            fail();
        } catch (SQLException e) {
        }

        verify(stat).executeUpdate(query, columnNames);
        verifyListenerForException(listener, "executeUpdate", query, query, columnNames);
    }


    @Test
    public void testExecute() throws Throwable {
        final String query = "select * from emp";

        Statement stat = mock(Statement.class);
        when(stat.execute(query)).thenReturn(true);
        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        Method method = Statement.class.getMethod("execute", String.class);
        Object result = logic.invoke(method, new Object[]{query});

        assertThat(result).isEqualTo(true);
        verify(stat).execute(query);
        verifyListener(listener, "execute", query, query);
    }

    @Test
    public void testExecuteForException() throws Throwable {
        final String query = "select * from emp";

        Statement stat = mock(Statement.class);
        when(stat.execute(query)).thenThrow(new SQLException());
        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        try {
            Method method = Statement.class.getMethod("execute", String.class);
            logic.invoke(method, new Object[]{query});
            fail();
        } catch (SQLException e) {
        }

        verify(stat).execute(query);
        verifyListenerForException(listener, "execute", query, query);
    }

    @Test
    public void testExecuteWithAutoGeneratedKeys() throws Throwable {
        final String query = "select * from emp";

        Statement stat = mock(Statement.class);
        when(stat.execute(query, Statement.RETURN_GENERATED_KEYS)).thenReturn(true);

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        Method method = Statement.class.getMethod("execute", String.class, int.class);
        Object result = logic.invoke(method, new Object[]{query, Statement.RETURN_GENERATED_KEYS});

        assertThat(result).isEqualTo(true);
        verify(stat).execute(query, Statement.RETURN_GENERATED_KEYS);
        verifyListener(listener, "execute", query, query, Statement.RETURN_GENERATED_KEYS);
    }

    @Test
    public void testExecuteWithAutoGeneratedKeysForException() throws Throwable {
        final String query = "select * from emp";

        Statement stat = mock(Statement.class);
        when(stat.execute(query, Statement.RETURN_GENERATED_KEYS)).thenThrow(new SQLException());

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        try {
            Method method = Statement.class.getMethod("execute", String.class, int.class);
            logic.invoke(method, new Object[]{query, Statement.RETURN_GENERATED_KEYS});
            fail();
        } catch (SQLException e) {
        }

        verify(stat).execute(query, Statement.RETURN_GENERATED_KEYS);
        verifyListenerForException(listener, "execute", query, query, Statement.RETURN_GENERATED_KEYS);
    }

    @Test
    public void testExecuteWithColumnIndexes() throws Throwable {
        final String query = "select * from emp";
        final int[] columnIndexes = {1, 2, 3};

        Statement stat = mock(Statement.class);
        when(stat.execute(query, columnIndexes)).thenReturn(true);

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        Method method = Statement.class.getMethod("execute", String.class, int[].class);
        Object result = logic.invoke(method, new Object[]{query, columnIndexes});

        assertThat(result).isEqualTo(true);
        verify(stat).execute(query, columnIndexes);
        verifyListener(listener, "execute", query, query, columnIndexes);
    }

    @Test
    public void testExecuteWithColumnIndexesForException() throws Throwable {
        final String query = "select * from emp";
        final int[] columnIndexes = {1, 2, 3};

        Statement stat = mock(Statement.class);
        when(stat.execute(query, columnIndexes)).thenThrow(new SQLException());

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        try {
            Method method = Statement.class.getMethod("execute", String.class, int[].class);
            logic.invoke(method, new Object[]{query, columnIndexes});
            fail();
        } catch (SQLException e) {
        }

        verify(stat).execute(query, columnIndexes);
        verifyListenerForException(listener, "execute", query, query, columnIndexes);
    }

    @Test
    public void testExecuteWithColumnNames() throws Throwable {
        final String query = "select * from emp";
        final String[] columnNames = {"foo", "bar", "baz"};

        Statement stat = mock(Statement.class);
        when(stat.execute(query, columnNames)).thenReturn(true);

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        Method method = Statement.class.getMethod("execute", String.class, String[].class);
        Object result = logic.invoke(method, new Object[]{query, columnNames});

        assertThat(result).isEqualTo(true);
        verify(stat).execute(query, columnNames);
        verifyListener(listener, "execute", query, query, columnNames);

    }

    @Test
    public void testExecuteWithColumnNamesForException() throws Throwable {
        final String query = "select * from emp";
        final String[] columnNames = {"foo", "bar", "baz"};

        Statement stat = mock(Statement.class);
        when(stat.execute(query, columnNames)).thenThrow(new SQLException());

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        try {
            Method method = Statement.class.getMethod("execute", String.class, String[].class);
            logic.invoke(method, new Object[]{query, columnNames});
            fail();
        } catch (SQLException e) {
        }

        verify(stat).execute(query, columnNames);
        verifyListenerForException(listener, "execute", query, query, columnNames);

    }

    @Test
    public void testExecuteQuery() throws Throwable {
        final String query = "select * from emp";

        Statement stat = mock(Statement.class);
        ResultSet rs = mock(ResultSet.class);
        when(stat.executeQuery(query)).thenReturn(rs);

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        Method method = Statement.class.getMethod("executeQuery", String.class);
        Object result = logic.invoke(method, new Object[]{query});

        assertThat(result).isEqualTo(rs);
        verify(stat).executeQuery(query);
        verifyListener(listener, "executeQuery", query, query);
    }

    @Test
    public void testExecuteQueryWithException() throws Throwable {
        final String query = "select * from emp";

        Statement stat = mock(Statement.class);
        when(stat.executeQuery(query)).thenThrow(new SQLException());

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        try {
            Method method = Statement.class.getMethod("executeQuery", String.class);
            logic.invoke(method, new Object[]{query});
            fail();
        } catch (SQLException e) {
        }

        verify(stat).executeQuery(query);
        verifyListenerForException(listener, "executeQuery", query, query);
    }

    @Test
    public void testExecuteLargeUpdate() throws Throwable {
        final String query = "select * from emp";

        Statement stat = mock(Statement.class);
        when(stat.executeLargeUpdate(query)).thenReturn(100L);

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        Method method = Statement.class.getMethod("executeLargeUpdate", String.class);
        Object result = logic.invoke(method, new Object[]{query});

        assertThat(result).isEqualTo(100L);
        verify(stat).executeLargeUpdate(query);
        verifyListener(listener, "executeLargeUpdate", query, query);
    }


    private StatementProxyLogic getProxyLogic(Statement statement, QueryExecutionListener listener, Connection proxyConnection) {
        return getProxyLogic(statement, listener, proxyConnection, false, false);
    }

    private StatementProxyLogic getProxyLogic(Statement statement, QueryExecutionListener listener, Connection proxyConnection,
                                              boolean createResultSetProxy, boolean createGenerateKeysProxy) {
        ConnectionInfo connectionInfo = new ConnectionInfo();
        connectionInfo.setDataSourceName(DS_NAME);

        ProxyConfig proxyConfig = ProxyConfig.Builder.create()
                .queryListener(listener)
                .resultSetProxyLogicFactory(createResultSetProxy ? new SimpleResultSetProxyLogicFactory() : null)
                .generatedKeysProxyLogicFactory(createGenerateKeysProxy ? new SimpleResultSetProxyLogicFactory() : null)
                .build();

        return StatementProxyLogic.Builder.create()
                .statement(statement, StatementType.STATEMENT)
                .connectionInfo(connectionInfo)
                .proxyConnection(proxyConnection)
                .proxyConfig(proxyConfig)
                .build();
    }

    @SuppressWarnings("unchecked")
    private void verifyListener(QueryExecutionListener listener, String methodName, String query, Object... methodArgs) {

        ArgumentCaptor<ExecutionInfo> executionInfoCaptor = ArgumentCaptor.forClass(ExecutionInfo.class);
        ArgumentCaptor<List> queryInfoListCaptor = ArgumentCaptor.forClass(List.class);

        verify(listener).afterQuery(executionInfoCaptor.capture(), queryInfoListCaptor.capture());

        ExecutionInfo execInfo = executionInfoCaptor.getValue();
        assertThat(execInfo.getMethod()).isNotNull();
        assertThat(execInfo.getMethod().getName()).isEqualTo(methodName);

        assertThat(execInfo.getMethodArgs()).hasSize(methodArgs.length);
        assertThat(execInfo.getMethodArgs()).contains(methodArgs);
        assertThat(execInfo.getDataSourceName()).isEqualTo(DS_NAME);
        assertThat(execInfo.getThrowable()).isNull();
        assertThat(execInfo.isBatch()).isFalse();
        assertThat(execInfo.getBatchSize()).isEqualTo(0);

        List<QueryInfo> queryInfoList = queryInfoListCaptor.getValue();
        assertThat(queryInfoList).hasSize(1);
        QueryInfo queryInfo = queryInfoList.get(0);
        assertThat(queryInfo.getQuery()).isEqualTo(query);
    }

    @SuppressWarnings("unchecked")
    private void verifyListenerForException(QueryExecutionListener listener, String methodName,
                                            String query, Object... methodArgs) {

        ArgumentCaptor<ExecutionInfo> executionInfoCaptor = ArgumentCaptor.forClass(ExecutionInfo.class);
        ArgumentCaptor<List> queryInfoListCaptor = ArgumentCaptor.forClass(List.class);

        verify(listener).afterQuery(executionInfoCaptor.capture(), queryInfoListCaptor.capture());

        ExecutionInfo execInfo = executionInfoCaptor.getValue();
        assertThat(execInfo.getMethod()).isNotNull();
        assertThat(execInfo.getMethod().getName()).isEqualTo(methodName);

        assertThat(execInfo.getMethodArgs()).hasSize(methodArgs.length);
        assertThat(execInfo.getMethodArgs()).contains(methodArgs);
        assertThat(execInfo.getDataSourceName()).isEqualTo(DS_NAME);
        assertThat(execInfo.getThrowable()).isInstanceOf(SQLException.class);

        List<QueryInfo> queryInfoList = queryInfoListCaptor.getValue();
        assertThat(queryInfoList).hasSize(1);
        QueryInfo queryInfo = queryInfoList.get(0);
        assertThat(queryInfo.getQuery()).isEqualTo(query);
    }


    @Test
    public void testAddBatchException() throws Throwable {
        final String queryA = "insert into emp (id, name) values (1, 'foo')";
        final String queryB = "insert into emp (id, name) values (2, 'bar')";

        Statement stat = mock(Statement.class);
        doThrow(new SQLException()).when(stat).addBatch(queryB);

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        Method method = Statement.class.getMethod("addBatch", String.class);
        logic.invoke(method, new Object[]{queryA});

        try {
            logic.invoke(method, new Object[]{queryB});
            fail();
        } catch (SQLException e) {
        }

        verify(stat).addBatch(queryA);

    }

    @Test
    public void testExecuteBatch() throws Throwable {
        final String queryA = "insert into emp (id, name) values (1, 'foo')";
        final String queryB = "insert into emp (id, name) values (2, 'bar')";
        final String queryC = "insert into emp (id, name) values (3, 'baz')";

        Statement stat = mock(Statement.class);
        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        // run
        Method method = Statement.class.getMethod("addBatch", String.class);
        logic.invoke(method, new Object[]{queryA});
        logic.invoke(method, new Object[]{queryB});
        logic.invoke(method, new Object[]{queryC});

        method = Statement.class.getMethod("executeBatch");
        Object result = logic.invoke(method, null);

        assertThat(result).isNull();
        verify(stat).addBatch(queryA);
        verify(stat).addBatch(queryB);
        verify(stat).addBatch(queryC);
        verify(stat).executeBatch();
        verifyListenerForBatchExecution("executeBatch", listener, queryA, queryB, queryC);

    }

    @Test
    public void testExecuteBatchForException() throws Throwable {
        final String queryA = "insert into emp (id, name) values (1, 'foo')";
        final String queryB = "insert into emp (id, name) values (2, 'bar')";
        final String queryC = "insert into emp (id, name) values (3, 'baz')";

        Statement stat = mock(Statement.class);
        when(stat.executeBatch()).thenThrow(new SQLException());

        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        // run
        Method method = Statement.class.getMethod("addBatch", String.class);
        logic.invoke(method, new Object[]{queryA});
        logic.invoke(method, new Object[]{queryB});
        logic.invoke(method, new Object[]{queryC});

        try {
            method = Statement.class.getMethod("executeBatch");
            logic.invoke(method, null);
            fail();
        } catch (SQLException e) {
        }

        verify(stat).addBatch(queryA);
        verify(stat).addBatch(queryB);
        verify(stat).addBatch(queryC);
        verify(stat).executeBatch();
        verifyListenerForExecuteBatchForException(listener, queryA, queryB, queryC);

    }

    @Test
    public void testExecuteBatchWithClearBatch() throws Throwable {
        final String queryA = "insert into emp (id, name) values (1, 'foo')";
        final String queryB = "insert into emp (id, name) values (2, 'bar')";
        final String queryC = "insert into emp (id, name) values (3, 'baz')";

        Statement stat = mock(Statement.class);
        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        // run
        Method addBatch = Statement.class.getMethod("addBatch", String.class);
        Method clearBatch = Statement.class.getMethod("clearBatch");
        Method executeBatch = Statement.class.getMethod("executeBatch");

        logic.invoke(addBatch, new Object[]{queryA});
        logic.invoke(clearBatch, null);
        logic.invoke(addBatch, new Object[]{queryB});
        logic.invoke(addBatch, new Object[]{queryC});
        Object result = logic.invoke(executeBatch, null);

        assertThat(result).isNull();
        verify(stat).addBatch(queryA);
        verify(stat).clearBatch();
        verify(stat).addBatch(queryB);
        verify(stat).addBatch(queryC);
        verify(stat).executeBatch();
        verifyListenerForBatchExecution("executeBatch", listener, queryB, queryC);

    }

    @Test
    public void testExecuteLargeBatch() throws Throwable {
        final String queryA = "insert into emp (id, name) values (1, 'foo')";
        final String queryB = "insert into emp (id, name) values (2, 'bar')";
        final String queryC = "insert into emp (id, name) values (3, 'baz')";

        Statement stat = mock(Statement.class);
        QueryExecutionListener listener = mock(QueryExecutionListener.class);
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        // run
        Method method = Statement.class.getMethod("addBatch", String.class);
        logic.invoke(method, new Object[]{queryA});
        logic.invoke(method, new Object[]{queryB});
        logic.invoke(method, new Object[]{queryC});

        method = Statement.class.getMethod("executeLargeBatch");
        Object result = logic.invoke(method, null);

        assertThat(result).isNull();
        verify(stat).addBatch(queryA);
        verify(stat).addBatch(queryB);
        verify(stat).addBatch(queryC);
        verify(stat).executeLargeBatch();
        verifyListenerForBatchExecution("executeLargeBatch", listener, queryA, queryB, queryC);
    }

    @SuppressWarnings("unchecked")
    private void verifyListenerForBatchExecution(String batchMethod, QueryExecutionListener listener, String... queries) {
        ArgumentCaptor<ExecutionInfo> executionInfoCaptor = ArgumentCaptor.forClass(ExecutionInfo.class);
        ArgumentCaptor<List> queryInfoListCaptor = ArgumentCaptor.forClass(List.class);

        verify(listener).afterQuery(executionInfoCaptor.capture(), queryInfoListCaptor.capture());

        ExecutionInfo execInfo = executionInfoCaptor.getValue();
        assertThat(execInfo.getMethod()).isNotNull();
        assertThat(execInfo.getMethod().getName()).isEqualTo(batchMethod);
        assertThat(execInfo.getDataSourceName()).isEqualTo(DS_NAME);
        assertThat(execInfo.getMethodArgs()).isNull();
        assertThat(execInfo.isBatch()).isTrue();
        assertThat(execInfo.getBatchSize()).isEqualTo(queries.length);

        List<QueryInfo> queryInfoList = queryInfoListCaptor.getValue();

        assertThat(queryInfoList).isNotNull();
        assertThat(queryInfoList).hasSize(queries.length);

        for (int i = 0; i < queries.length; i++) {
            String expectedQuery = queries[i];
            QueryInfo queryInfo = queryInfoList.get(i);
            assertThat(queryInfo.getQuery()).isEqualTo(expectedQuery);
            assertThat(queryInfo.getParametersList()).isEmpty();
        }
    }

    @SuppressWarnings("unchecked")
    private void verifyListenerForExecuteBatchForException(QueryExecutionListener listener, String... queries) {
        ArgumentCaptor<ExecutionInfo> executionInfoCaptor = ArgumentCaptor.forClass(ExecutionInfo.class);
        ArgumentCaptor<List> queryInfoListCaptor = ArgumentCaptor.forClass(List.class);

        verify(listener).afterQuery(executionInfoCaptor.capture(), queryInfoListCaptor.capture());

        ExecutionInfo execInfo = executionInfoCaptor.getValue();
        assertThat(execInfo.getMethod()).isNotNull();
        assertThat(execInfo.getMethod().getName()).isEqualTo("executeBatch");
        assertThat(execInfo.getDataSourceName()).isEqualTo(DS_NAME);
        assertThat(execInfo.getMethodArgs()).isNull();
        assertThat(execInfo.getThrowable()).isInstanceOf(SQLException.class);
        assertThat(execInfo.isBatch()).isTrue();
        assertThat(execInfo.getBatchSize()).isEqualTo(queries.length);


        List<QueryInfo> queryInfoList = queryInfoListCaptor.getValue();

        assertThat(queryInfoList).hasSize(queries.length);

        for (int i = 0; i < queries.length; i++) {
            String expectedQuery = queries[i];
            QueryInfo queryInfo = queryInfoList.get(i);
            assertThat(queryInfo.getQuery()).isEqualTo(expectedQuery);
            assertThat(queryInfo.getParametersList()).isEmpty();
        }

    }

    @Test
    public void testGetTarget() throws Throwable {
        Statement stmt = mock(Statement.class);
        StatementProxyLogic logic = getProxyLogic(stmt, null, null);

        Method method = ProxyJdbcObject.class.getMethod("getTarget");
        Object result = logic.invoke(method, null);

        assertThat(result).isNotNull();
        assertThat(result).isSameAs(stmt);

        Statement resultStmt = (Statement) result;
        assertThat(resultStmt).isSameAs(stmt);

    }

    @Test
    public void testUnwrap() throws Throwable {
        Statement stmt = mock(Statement.class);
        when(stmt.unwrap(String.class)).thenReturn("called");

        StatementProxyLogic logic = getProxyLogic(stmt, null, null);

        Method method = Statement.class.getMethod("unwrap", Class.class);
        Object result = logic.invoke(method, new Object[]{String.class});

        verify(stmt).unwrap(String.class);
        assertThat(result).isEqualTo("called");

    }

    @Test
    public void testIsWrapperFor() throws Throwable {
        Statement stmt = mock(Statement.class);
        when(stmt.isWrapperFor(String.class)).thenReturn(true);

        StatementProxyLogic logic = getProxyLogic(stmt, null, null);

        Method method = Statement.class.getMethod("isWrapperFor", Class.class);
        Object result = logic.invoke(method, new Object[]{String.class});

        verify(stmt).isWrapperFor(String.class);
        assertThat(result).isEqualTo(true);
    }

    @Test
    public void testGetConnection() throws Throwable {
        Connection conn = mock(Connection.class);
        Statement stmt = mock(Statement.class);

        when(stmt.getConnection()).thenReturn(conn);
        StatementProxyLogic logic = getProxyLogic(stmt, null, conn);

        Method method = Statement.class.getMethod("getConnection");
        Object result = logic.invoke(method, null);

        assertThat(result).isSameAs(conn);

    }

    @Test
    public void testToString() throws Throwable {
        Statement stmt = mock(Statement.class);

        when(stmt.toString()).thenReturn("my ds");
        StatementProxyLogic logic = getProxyLogic(stmt, null, null);

        Method method = Object.class.getMethod("toString");
        Object result = logic.invoke(method, null);

        assertThat(result).isEqualTo(stmt.getClass().getSimpleName() + " [my ds]");

    }

    @Test
    public void testHashCode() throws Throwable {
        Statement stmt = mock(Statement.class);
        StatementProxyLogic logic = getProxyLogic(stmt, null, null);

        Method method = Object.class.getMethod("hashCode");
        Object result = logic.invoke(method, null);

        assertThat(result).isEqualTo(stmt.hashCode());

    }

    @Test
    public void testEquals() throws Throwable {
        Statement stmt = mock(Statement.class);
        StatementProxyLogic logic = getProxyLogic(stmt, null, null);

        Method method = Object.class.getMethod("equals", Object.class);

        // equals(null)
        Object result = logic.invoke(method, new Object[]{null});
        assertThat(result).isEqualTo(false);

        // equals(true)
        result = logic.invoke(method, new Object[]{stmt});
        assertThat(result).isEqualTo(true);
    }

    @Test
    public void proxyResultSet() throws Throwable {

        final AtomicReference<Object> listenerReceivedResult = new AtomicReference<Object>();
        QueryExecutionListener listener = new NoOpQueryExecutionListener() {
            @Override
            public void afterQuery(ExecutionInfo execInfo, List<QueryInfo> queryInfoList) {
                listenerReceivedResult.set(execInfo.getResult());
            }
        };


        ResultSetMetaData metaData = mock(ResultSetMetaData.class);

        ResultSet resultSet = mock(ResultSet.class);
        when(resultSet.getMetaData()).thenReturn(metaData);


        Statement stmt = mock(Statement.class);
        when(stmt.executeQuery(anyString())).thenReturn(resultSet);
        when(stmt.getGeneratedKeys()).thenReturn(resultSet);
        when(stmt.getResultSet()).thenReturn(resultSet);
        StatementProxyLogic logic = getProxyLogic(stmt, listener, null, true, false);


        // "executeQuery", "getGeneratedKeys", "getResultSet"
        Method executeQueryMethod = Statement.class.getMethod("executeQuery", String.class);
        Method getGeneratedKeysMethod = Statement.class.getMethod("getGeneratedKeys");
        Method getResultSetMethod = Statement.class.getMethod("getResultSet");
        Object result;

        // check "executeQuery"
        result = logic.invoke(executeQueryMethod, new Object[]{"SELECT *"});
        assertThat(result).isInstanceOf(ResultSet.class);
        assertTrue(Proxy.isProxyClass(result.getClass()));
        assertTrue(Proxy.getInvocationHandler(result).getClass().equals(ResultSetInvocationHandler.class));
        assertThat(listenerReceivedResult.get()).as("listener should receive proxied resultset").isSameAs(result);

        listenerReceivedResult.set(null);

        // check "getResultSet"
        result = logic.invoke(getResultSetMethod, null);
        assertThat(result).isInstanceOf(ResultSet.class);
        assertTrue(Proxy.isProxyClass(result.getClass()));
        assertTrue(Proxy.getInvocationHandler(result).getClass().equals(ResultSetInvocationHandler.class));
        assertThat(listenerReceivedResult).as("listener should not be called").hasValue(null);

        listenerReceivedResult.set(null);

        // check "getGeneratedKeys". generated keys has separate configuration
        result = logic.invoke(getGeneratedKeysMethod, null);
        assertThat(result).isInstanceOf(ResultSet.class);
        assertFalse(Proxy.isProxyClass(result.getClass()));


    }

    @Test
    public void proxyGeneratedKeysResultSet() throws Throwable {

        final AtomicReference<Object> listenerReceivedResult = new AtomicReference<Object>();
        QueryExecutionListener listener = new NoOpQueryExecutionListener() {
            @Override
            public void afterQuery(ExecutionInfo execInfo, List<QueryInfo> queryInfoList) {
                listenerReceivedResult.set(execInfo.getResult());
            }
        };


        ResultSetMetaData metaData = mock(ResultSetMetaData.class);

        ResultSet resultSet = mock(ResultSet.class);
        when(resultSet.getMetaData()).thenReturn(metaData);


        Statement stmt = mock(Statement.class);
        when(stmt.executeQuery(anyString())).thenReturn(resultSet);
        when(stmt.getGeneratedKeys()).thenReturn(resultSet);
        when(stmt.getResultSet()).thenReturn(resultSet);
        StatementProxyLogic logic = getProxyLogic(stmt, listener, null, false, true);


        // "executeQuery", "getGeneratedKeys", "getResultSet"
        Method executeQueryMethod = Statement.class.getMethod("executeQuery", String.class);
        Method getGeneratedKeysMethod = Statement.class.getMethod("getGeneratedKeys");
        Method getResultSetMethod = Statement.class.getMethod("getResultSet");
        Object result;

        // check "getGeneratedKeys"
        result = logic.invoke(getGeneratedKeysMethod, null);
        assertThat(result).isInstanceOf(ResultSet.class);
        assertTrue(Proxy.isProxyClass(result.getClass()));
        assertTrue(Proxy.getInvocationHandler(result).getClass().equals(ResultSetInvocationHandler.class));
        assertThat(listenerReceivedResult).as("listener should not be called").hasValue(null);

        listenerReceivedResult.set(null);

        // check "executeQuery"
        result = logic.invoke(executeQueryMethod, new Object[]{"SELECT *"});
        assertThat(result).isInstanceOf(ResultSet.class);
        assertFalse(Proxy.isProxyClass(result.getClass()));

        listenerReceivedResult.set(null);

        // check "getResultSet"
        result = logic.invoke(getResultSetMethod, null);
        assertThat(result).isInstanceOf(ResultSet.class);
        assertFalse(Proxy.isProxyClass(result.getClass()));

    }

    @Test
    public void autoCloseGeneratedKeys() throws Throwable {

        ResultSet resultSet = mock(ResultSet.class);
        when(resultSet.isClosed()).thenReturn(false);

        Statement stmt = mock(Statement.class);
        when(stmt.getGeneratedKeys()).thenReturn(resultSet);

        // autoCloseGeneratedKeys=true
        ProxyConfig proxyConfig = ProxyConfig.Builder.create()
                .autoRetrieveGeneratedKeys(true)
                .autoCloseGeneratedKeys(true)
                .build();

        StatementProxyLogic logic = StatementProxyLogic.Builder.create()
                .statement(stmt, StatementType.STATEMENT)
                .connectionInfo(new ConnectionInfo())
                .proxyConfig(proxyConfig)
                .build();


        // execute
        Method execute = Statement.class.getMethod("execute", String.class, int.class);
        logic.invoke(execute, new Object[]{"SELECT *", Statement.RETURN_GENERATED_KEYS});

        verify(resultSet).close();


        reset(resultSet);

        // autoCloseGeneratedKeys=false
        proxyConfig = ProxyConfig.Builder.create()
                .autoRetrieveGeneratedKeys(true)
                .autoCloseGeneratedKeys(false)
                .build();

        logic = StatementProxyLogic.Builder.create()
                .statement(stmt, StatementType.STATEMENT)
                .connectionInfo(new ConnectionInfo())
                .proxyConfig(proxyConfig)
                .build();


        // execute
        logic.invoke(execute, new Object[]{"SELECT *", Statement.RETURN_GENERATED_KEYS});

        verify(resultSet, never()).close();

    }

    @Test
    public void methodExecutionListener() throws Throwable {
        CallCheckMethodExecutionListener listener = new CallCheckMethodExecutionListener();
        ProxyConfig proxyConfig = ProxyConfig.Builder.create().methodListener(listener).build();

        final String query = "insert into emp (id, name) values (1, 'foo')";

        Statement statement = mock(Statement.class);
        when(statement.executeUpdate(query)).thenReturn(100);

        ConnectionInfo connectionInfo = new ConnectionInfo();
        connectionInfo.setDataSourceName(DS_NAME);

        StatementProxyLogic logic = new StatementProxyLogic.Builder()
                .statement(statement, StatementType.STATEMENT)
                .connectionInfo(connectionInfo)
                .proxyConfig(proxyConfig)
                .build();

        Method method = Statement.class.getMethod("executeUpdate", String.class);
        logic.invoke(method, new Object[]{query});

        assertTrue(listener.isBeforeMethodCalled());
        assertTrue(listener.isAfterMethodCalled());


        MethodExecutionContext executionContext = listener.getAfterMethodContext();
        assertSame("method should come from interface",
                Statement.class, executionContext.getMethod().getDeclaringClass());
        assertSame("executeUpdate", executionContext.getMethod().getName());
        assertSame(statement, executionContext.getTarget());
        assertSame(connectionInfo, executionContext.getConnectionInfo());
    }

    @Test
    public void elapsedTimeForQueryFailure() throws Throwable {
        final String query = "insert into emp (id, name) values (1, 'foo')";

        Statement stat = mock(Statement.class);
        when(stat.executeUpdate(query)).then(new Answer<Integer>() {
            @Override
            public Integer answer(InvocationOnMock invocation) throws Throwable {
                TimeUnit.MILLISECONDS.sleep(3);  // sleep 3 msec to make sure some time elapse
                throw new SQLException();
            }
        });

        final AtomicLong elapsedTimeHolder = new AtomicLong(-1);

        QueryExecutionListener listener = new QueryExecutionListener() {
            @Override
            public void beforeQuery(ExecutionInfo execInfo, List<QueryInfo> queryInfoList) {
            }

            @Override
            public void afterQuery(ExecutionInfo execInfo, List<QueryInfo> queryInfoList) {
                elapsedTimeHolder.set(execInfo.getElapsedTime());
            }
        };
        StatementProxyLogic logic = getProxyLogic(stat, listener, null);

        try {
            Method method = Statement.class.getMethod("executeUpdate", String.class);
            logic.invoke(method, new Object[]{query});
            fail();
        } catch (SQLException e) {
        }

        assertThat(elapsedTimeHolder).hasValueGreaterThanOrEqualTo(3);
    }

    @Test
    public void getGeneratedKeysShouldNotInvokeQueryListener() throws Throwable {
        Statement stmt = mock(Statement.class);
        QueryExecutionListener listener = mock(QueryExecutionListener.class);

        StatementProxyLogic logic = getProxyLogic(stmt, listener, null, true, false);

        Method getGeneratedKeysMethod = Statement.class.getMethod("getGeneratedKeys");

        logic.invoke(getGeneratedKeysMethod, null);

        // beforeQuery()/afterQuery() should not be called
        verify(listener, never()).beforeQuery(any(ExecutionInfo.class), ArgumentMatchers.<QueryInfo>anyList());
        verify(listener, never()).afterQuery(any(ExecutionInfo.class), ArgumentMatchers.<QueryInfo>anyList());
    }

    @Test
    public void getResultSetShouldNotInvokeQueryListener() throws Throwable {
        Statement stmt = mock(Statement.class);
        QueryExecutionListener listener = mock(QueryExecutionListener.class);

        StatementProxyLogic logic = getProxyLogic(stmt, listener, null, true, false);

        Method getResultSet = Statement.class.getMethod("getResultSet");

        logic.invoke(getResultSet, null);

        // beforeQuery()/afterQuery() should not be called
        verify(listener, never()).beforeQuery(any(ExecutionInfo.class), ArgumentMatchers.<QueryInfo>anyList());
        verify(listener, never()).afterQuery(any(ExecutionInfo.class), ArgumentMatchers.<QueryInfo>anyList());
    }

}
